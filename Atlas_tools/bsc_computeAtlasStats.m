function [atlasGeometryStats] =bsc_computeAtlasStats(atlas)
% [fsStats] =bsc_computeFresurferStats(fsDir)
%
% This function computes two primary groups of geometric stats: 
%  (1) volume based (i.e. actual volume and total brain proportion)
%  (2) boundary based (i.e. the 3D bounding box coordinates for each roi)
%
% Inputs:
% -wbfg: a whole brain fiber group structure
% -atlas: path to an atlas or an atlas object itself
% -categoryClassification: the classification structure resulting from the
% classification segmentation.  Done outside of this function to avoid
% doing it repeatedly

% Outputs:
% -fsStats:  A table with relevant freesurfer data

% (C) Daniel Bullock, 2020, Indiana University
%%
if ischar(atlas)
    %load the atlas if its a path
    atlas=niftiRead(atlas);
else
    %do nothing
end
%
% find all of the unique labels in the atlas
% And remove zero
uniqueLables=unique(atlas.data);
%if you want to be agnostic about which label is actually the background ,
%you could just find whichever label is the most common, and exclude that.
uniqueNoZero = uniqueLables(find(uniqueLables~=0));
%
%  Create an roi for all of these ROIS (to do a computation of whole brain
%  volume
%  NOTE:  YOU PROBABLY WANT TO EXCLUDE SOME OF THESE ROIS, BUT WE CAN TAKE
%  CARE OF THAT IN A LATER VERSION
[wholeBrainRoi] =bsc_roiFromAtlasNums(atlasPath,uniqueNoZero',1);
%kind of like a proxy for whole brain volume, except the units her are kind
%of ambiguous.  When you devide a roi's coordinate number by this, the
%units cancel out and you get the appropriate proportion.
wholeBrainCoordNumber=length(wholeBrainRoi.coords);

%set the column names for the table now
columnNames={'ROI_name','BrainVol_proportion','MAS_BBox_Coord','LAS_BBox_Coord','MPS_BBox_Coord','LPS_BBox_Coord','MAI_BBox_Coord','LAI_BBox_Coord','MPI_BBox_Coord','LPI_BBox_Coord'};
%createROINameVec
roiNameVec=[];
tableData=cell([length(uniqueNoZero),length(columnNames)]);

%now loop over the rois
for iROIs=1:length(uniqueNoZero)
    %extract current ROI
    [currentROI] =bsc_roiFromAtlasNums(atlas,uniqueNoZero(iROIs),1);
    %creat current roi name for table
    currentName=strcat('ROI_',currentROI.name);
    %compute whole brain proportion
    wholeBrainProportion=length(currentROI.coords)/wholeBrainCoordNumber;
    %begin computing the borders
    medialBorder=bsc_planeFromROI_v2(currentROI,'medial',atlas);
    lateralBorder=bsc_planeFromROI_v2(currentROI,'lateral',atlas);
    anteriorBorder=bsc_planeFromROI_v2(currentROI,'anterior',atlas);
    posteriorBorder=bsc_planeFromROI_v2(currentROI,'posterior',atlas);
    superiorBorder=bsc_planeFromROI_v2(currentROI,'superior',atlas);
    inferiorBorder=bsc_planeFromROI_v2(currentROI,'inferior',atlas);
    %now we have all the borders, however, instead of using the roi borders
    %themselves, we'll use the names (which were generated by the plans
    %themselves) as a shortcut to finding the bounding box verticies.
    %In a certian sense, there's a bit of redundancy in this (we are
    %expanding the number of descriptors from 6 to 8), but  we'll need the
    %coordinate format for doing the mni transfer later anyways.
    
    % M=Medial, L=Lateral, A=Anterior, P=Posterior, S=Superior, I=Inferior
    % indexing inefficiently because matlab
    mUnderscoreIndexes=strfind(medialBorder.name,'_');
    M_coord=str2num(medialBorder.name(mUnderscoreIndexes(1)+1:mUnderscoreIndexes(2)-1));
    
    lUnderscoreIndexes=strfind(lateralBorder.name,'_');
    L_coord=str2num(lateralBorder.name(lUnderscoreIndexes(1)+1:lUnderscoreIndexes(2)-1));
    
    aUnderscoreIndexes=strfind(anteriorBorder.name,'_');
    A_coord=str2num(anteriorBorder.name(aUnderscoreIndexes(1)+1:aUnderscoreIndexes(2)-1));
    
    pUnderscoreIndexes=strfind(posteriorBorder.name,'_');
    P_coord=str2num(posteriorBorder.name(pUnderscoreIndexes(1)+1:pUnderscoreIndexes(2)-1));
    
    sUnderscoreIndexes=strfind(superiorBorder.name,'_');
    S_coord=str2num(superiorBorder.name(sUnderscoreIndexes(1)+1:sUnderscoreIndexes(2)-1));
    
    iUnderscoreIndexes=strfind(inferiorBorder.name,'_');
    I_coord=str2num(inferiorBorder.name(iUnderscoreIndexes(1)+1:iUnderscoreIndexes(2)-1));
    
    %now lets convert these into the vertex coordinates of a bounding box
    %NOTE: THIS COULD LEAD TO SOME WEIRD OUTPUTS IF THE ROI INFREQUENTLY
    %(ACROSS SUBJECTS) CROSSES THE MIDLINE, OR DOES OTHER WEIRD STUFF.
    
    MAS_Coord=[M_coord,A_coord,S_coord];
    LAS_Coord=[L_coord,A_coord,S_coord];
    MPS_Coord=[M_coord,P_coord,S_coord];
    LPS_Coord=[L_coord,P_coord,S_coord];
    MAI_Coord=[M_coord,A_coord,I_coord];
    LAI_Coord=[L_coord,A_coord,I_coord];
    MPI_Coord=[M_coord,P_coord,I_coord];
    LPI_Coord=[L_coord,P_coord,I_coord];
    
    %this is an inefficient approach, but it is done for the sake of
    %transparancy
    tableData{iROIs,1}=currentName;
    tableData{iROIs,2}=wholeBrainProportion;
    tableData{iROIs,3}=MAS_Coord;
    tableData{iROIs,4}=LAS_Coord;
    tableData{iROIs,5}=MPS_Coord;
    tableData{iROIs,6}=LPS_Coord;
    tableData{iROIs,7}=MAI_Coord;
    tableData{iROIs,8}=LAI_Coord;
    tableData{iROIs,9}=MPI_Coord;
    tableData{iROIs,10}=LPI_Coord;
end

%set it in a table
atlasGeometryStats=cell2table(tableData,'VariableNames',columnNames);
 
end